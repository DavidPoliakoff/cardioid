#include <iostream>
#include <iomanip>
#include <string>
#include <cassert>
#include <fstream>
#include <sstream>
#include <vector>
#include <mpi.h>
#include <algorithm>
#include <dirent.h>
#include <sys/stat.h>

#include "Simulate.hh"
#include "PerformanceTimers.hh"
#include "checkpointIO.hh"
#include "BucketOfBits.hh"
#include "AnatomyReader.hh"
#include "stateLoader.hh"
#include "cellState.hh"
#include "object_cc.hh"
#include "readPioFile.hh"
#include "mpiUtils.h"
#include "pio.h"
#include "units.h"
#include "ioUtils.h"

// collectGradientTraces.cc reads in the gradient data generated by e.g. the coarseningVoronoiGradient
// sensor and writes out data at each point as a function of time.  

using namespace std;
namespace
{
    void readGradientBucket(vector<vector<double> >& gData, unsigned snapIndex, vector<uint64_t>& gid, BucketOfBits* bucketP);
    void readGradientData(vector<vector<double> >& gData, unsigned snapIndex, vector<uint64_t>& gid, string dirName, const string filebase, double &time, int &nrecord);
}

MPI_Comm COMM_LOCAL = MPI_COMM_WORLD;

int main(int argc, char** argv)
{
   const string filebase("coarsened_anatomy");
   const string outputDir("gradientTraces");
   const bool printAll = false;  // print individual traces for each point
   
   int nTasks, myRank;
   MPI_Init(&argc,&argv);
   MPI_Comm_size(MPI_COMM_WORLD, &nTasks);
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);  

   if (argc < 4)
   {
      if (myRank == 0)
         cout << "Usage:  collectGradientTraces [total # of snapshots to process] [period between snapshots] [first snapshot #]" << endl << endl;
      exit(1);
   }

   int nSnaps = atoi(argv[1]);
   int snapPeriod = atoi(argv[2]);
   int firstSnapNum = 0;
   if (argc == 4)
      firstSnapNum = atoi(argv[3]);
   
   // store gradient data for entire trace in memory, if we can
   vector<vector<double> > gradientData;
   vector<uint64_t> gid;
   gradientData.resize(nSnaps);
   
   unsigned snapCnt = 0;
   for (unsigned isnap=0; isnap<nSnaps; isnap++)
   {   
      int thisSnapNum = firstSnapNum + isnap*snapPeriod;
      ostringstream oss;
      oss.width(12);  oss.fill('0');  oss << thisSnapNum;      
      string snapDir = "snapshot." + oss.str();

      // test if snapshot dir exists
      struct stat st1;
      if (!(stat(snapDir.c_str(),&st1)==0 && S_ISDIR( st1.st_mode )) )
      {
         if (myRank == 0)
            cout << "ERROR:  " << snapDir << " does not exist!" << endl;
         exit(1);
      }

      if (myRank == 0)
         cout << "Reading " << snapDir << "..." << endl;
      
      // read gradient data from snapshot directory, store in gradientData
      int nrecord;
      double time;
      readGradientData(gradientData,snapCnt,gid,snapDir,filebase,time,nrecord);
      snapCnt++;
   }

   // compute max, min, avg values of gradient across all tasks
   unsigned nLocal = gradientData[0].size()/3;
   double minGrad = 1.E+19;
   double maxGrad = -1.E+19;
   double minDelta = 1.E+19;
   double maxDelta = -1.E+19;
   double gradSum = 0.0;
   double deltaSum = 0.0;

   for (unsigned ii=0; ii<nLocal; ii++)
   {
      double lastVal = 0.0;
      for (unsigned jj=0; jj<snapCnt; jj++)
      {
         double gradx = gradientData[jj][3*ii];
         double grady = gradientData[jj][3*ii+1];
         double gradz = gradientData[jj][3*ii+2];
         double gradLen = sqrt(gradx*gradx + grady*grady + gradz*gradz);
         double deltaGrad = abs(gradLen-lastVal);
         if (jj == 0)
            deltaGrad = 0.0;
         lastVal = gradLen;

         if (gradLen > maxGrad) maxGrad = gradLen;
         if (gradLen < minGrad) minGrad = gradLen;
         if (deltaGrad > maxDelta) maxDelta = deltaGrad;
         if (deltaGrad < minDelta) minDelta = deltaGrad;
         gradSum += gradLen;
         deltaSum += deltaGrad;
      }
   }
   double globalMinGrad, globalMaxGrad;
   double globalMinDelta, globalMaxDelta;
   MPI_Allreduce(&minGrad,&globalMinGrad,1,MPI_DOUBLE,MPI_MIN,MPI_COMM_WORLD);
   MPI_Allreduce(&maxGrad,&globalMaxGrad,1,MPI_DOUBLE,MPI_MAX,MPI_COMM_WORLD);
   MPI_Allreduce(&minDelta,&globalMinDelta,1,MPI_DOUBLE,MPI_MIN,MPI_COMM_WORLD);
   MPI_Allreduce(&maxDelta,&globalMaxDelta,1,MPI_DOUBLE,MPI_MAX,MPI_COMM_WORLD);
   
   unsigned nGlobal;
   double avgGrad, avgDelta;
   MPI_Allreduce(&nLocal,&nGlobal,1,MPI_UNSIGNED,MPI_SUM,MPI_COMM_WORLD);
   MPI_Allreduce(&gradSum,&avgGrad,1,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD);
   MPI_Allreduce(&deltaSum,&avgDelta,1,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD);
   avgGrad /= nGlobal;
   avgDelta /= nGlobal;
   
   if (myRank == 0)
   {
      cout << "Gradient:  avg = " << avgGrad << ", min = " <<
          globalMinGrad << ", max = " << globalMaxGrad << endl;
      cout << "Delta gradient:  avg = " << avgDelta << ", min = " <<
          globalMinDelta << ", max = " << globalMaxDelta << endl;
   }

   // print min and max gradient, delta values for each gid to a single file
   {
      
      ostringstream oss;
      oss.width(3);  oss.fill('0');  oss << myRank;
      string minmaxfile = "minmaxGrad.pe" + oss.str() + ".dat";
      ofstream os;
      os.open(minmaxfile.c_str());
      os.setf(ios::scientific,ios::floatfield);
      os << setprecision(12);
      for (unsigned ii=0; ii<nLocal; ii++)
      {
         minGrad = 1.E+19;
         maxGrad = -1.E+19;
         minDelta = 1.E+19;
         maxDelta = -1.E+19;

         double lastVal = 0.0;
         for (unsigned jj=0; jj<snapCnt; jj++)
         {
            double gradx = gradientData[jj][3*ii];
            double grady = gradientData[jj][3*ii+1];
            double gradz = gradientData[jj][3*ii+2];
            double gradLen = sqrt(gradx*gradx + grady*grady + gradz*gradz);
            double deltaGrad = abs(gradLen-lastVal);
            if (jj == 0)
               deltaGrad = 0.0;
            lastVal = gradLen;
            
            if (gradLen > maxGrad) maxGrad = gradLen;
            if (gradLen < minGrad) minGrad = gradLen;
            if (deltaGrad > maxDelta) maxDelta = deltaGrad;
            if (deltaGrad < minDelta) minDelta = deltaGrad;
         }
         os << gid[ii] << "  " << minGrad << " " << maxGrad << " " << minDelta << " " << maxDelta << endl;
      }
      os.close();
   }


   // print all traces to separate files
   if (printAll)
   {
      // create output directory if it doesn't exist
      if ( myRank == 0 )
      {
         int mode = 0775;
         struct stat statbuf;
         int rc = stat(outputDir.c_str(), &statbuf);
         if (rc == -1)
         {
            cout << "Creating directory: " << outputDir << endl;
            rc = mkdir(outputDir.c_str(), mode);
            rc = stat(outputDir.c_str(), &statbuf);
         }
         if (rc != 0 || !(statbuf.st_mode))
         {
            cout << "ERROR: Can't stat directory " << outputDir << endl;
            MPI_Abort(MPI_COMM_WORLD,2);
         }
      }
      MPI_Barrier(MPI_COMM_WORLD);
   
      // print out gradient, second derivative vs. time
      for (unsigned ii=0; ii<nLocal; ii++)
      {
         ostringstream oss;
         oss.width(11);  oss.fill('0');  oss << gid[ii];
         string outfile = outputDir + "/gradTrace." + oss.str();
         ofstream os;
         os.open(outfile.c_str());
         os.setf(ios::scientific,ios::floatfield);
         os << setprecision(12);

         double lastVal = 0.0;
         for (unsigned jj=0; jj<snapCnt; jj++)
         {
            unsigned thisSnapNum = firstSnapNum + jj*snapPeriod;
            double gradx = gradientData[jj][3*ii];
            double grady = gradientData[jj][3*ii+1];
            double gradz = gradientData[jj][3*ii+2];
            double gradLen = sqrt(gradx*gradx + grady*grady + gradz*gradz);
            double deltaGrad = gradLen-lastVal;
            if (jj == 0)
               deltaGrad = 0.0;
            lastVal = gradLen;
            
            os << jj << "  " << gradLen << "  " << deltaGrad << endl;
         }
         os.close();
      }
   }
   
   if (myRank == 0)
      cout << "Finished!" << endl;
   MPI_Finalize();
   return 0;
}

namespace
{
    void readGradientBucket(vector<vector<double> >& gData, unsigned snapIndex, vector<uint64_t>& gid, BucketOfBits* bucketP)
    {
       const bool firstCall = gid.size() > 0 ? false : true;
          
       unsigned nRecords =  bucketP->nRecords();
       unsigned nFields =   bucketP->nFields();
       unsigned gidIndex =  bucketP->getIndex("gid");
       unsigned gxIndex =  bucketP->getIndex("gx");
       unsigned gyIndex =  bucketP->getIndex("gy");
       unsigned gzIndex =  bucketP->getIndex("gz");
       assert( gidIndex != nFields);
       if (firstCall)
          gid.resize(nRecords);
       gData[snapIndex].resize(3*nRecords);
       for (unsigned ii=0; ii<nRecords; ++ii)
       {
          uint64_t readGid;
          double readVal;
          BucketOfBits::Record rr = bucketP->getRecord(ii);
          rr.getValue(gidIndex, readGid);
          if (firstCall)
             gid[ii] = readGid;
          else
          {
             if (gid[ii] != readGid)
                cout << "ERROR:  readGid = " << readGid << ", gid[" << ii << "] = " << gid[ii] << endl;

             //assert(gid[ii] == readGid);
          }
          
          rr.getValue(gxIndex, readVal);
          gData[snapIndex][3*ii] = readVal;
          rr.getValue(gyIndex, readVal);
          gData[snapIndex][3*ii+1] = readVal;
          rr.getValue(gzIndex, readVal);
          gData[snapIndex][3*ii+2] = readVal;
       }
    }
    
    void readGradientData(vector<vector<double> >& gData, unsigned snapIndex, vector<uint64_t>& gid, string dirName, const string filebase, double &time, int &nrecord)
    {
       string dataFile = dirName + "/" + filebase + "#";
       PFILE* file = Popen(dataFile.c_str(), "r", MPI_COMM_WORLD);
       OBJECT* hObj = file->headerObject;

       //int nx, ny, nz;
       //objectGet(hObj, "nx", nx, "0");
       //objectGet(hObj, "ny", ny, "0");
       //objectGet(hObj, "nz", nz, "0");
       //assert(nx*ny*nz > 0);
       objectGet(hObj, "time", time, "0.0");
       objectGet(hObj, "nrecords", nrecord, "0");


       //ewd DEBUG
       //cout << "Opening " << dataFile << ", nrecords = " << nrecord << ", snapIndex = " << snapIndex << endl;

       
       // read gradient data
       BucketOfBits* bucketP = readPioFile(file);
       Pclose(file);
       readGradientBucket(gData, snapIndex, gid, bucketP);
       delete bucketP;       
    }

}
