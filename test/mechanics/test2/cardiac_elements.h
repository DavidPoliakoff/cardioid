#ifndef OOMPH_CARDIAC_ELEMENTS_HEADER
#define OOMPH_CARDIAC_ELEMENTS_HEADER

#include "cardiac_nodes.h"
#include "cardiac_utilities.h"
#include "cardiac_constitutive_laws.h"

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

//OOMPH-LIB includes
#include <constitutive.h>
#include <generic.h>
#include <solid.h>

#include <algorithm>
#include <string.h>


namespace oomph
{

/// \short Abstract class for data allocation in integration points
///
/// initialize_data_at_integration_points::initialize_data_at_integration_points
/// for every finite element. Function initializes different data such as transformation tensors and
/// active models.
class DataAtIntegrationPoints
{
public:
  /// This function is called to initialize data at integration points of finite elements
  /// by SolidMeshWithDataAtIntegrationPoints::initialize_data_at_integration_points.
  virtual void initialize_data_at_integration_points() = 0;
};

/// \short This finite element describes anisotropic material
///
/// In this class transformation tensors are defined at the nodes and interpolated at
/// integration points.
class AnisotropicFiniteElement : public virtual SolidFiniteElement,
  public virtual DataAtIntegrationPoints
{

public:
  /// \short Constructor
  AnisotropicFiniteElement() : SolidFiniteElement(), Transformations(0) {}

  ///Destructor to clean up any allocated memory
  virtual ~AnisotropicFiniteElement() {
    if(Transformations)
      delete [] Transformations;
  }

  /// Broken copy constructor
  AnisotropicFiniteElement(const AnisotropicFiniteElement&) {
    BrokenCopy::broken_copy("AnisotropicFiniteElement");
  }

  /// Broken assignment operator
  void operator=(const AnisotropicFiniteElement&) {
    BrokenCopy::broken_assign("AnisotropicFiniteElement");
  }

  /// This function interpolates transformation tensors at
  /// integration points from tensors defined at the nodes of the mesh
  void precalculate_transformation_tensor_at_gaussian_points() {
    for(unsigned ip = 0; ip < integral_pt()->nweight(); ip++) {

      const unsigned n_node = this->nnode();
      const unsigned n_position_type = this->nnodal_position_type();


      Shape psi(n_node, n_position_type);
      shape_at_knot(ip, psi);

      double trans[AnisotropicSolidNode::N_rotation_components] = {0};

      //Loop over nodes
      for(unsigned l = 0; l < n_node; l++)

        //Loop over the positional dofs
        for(unsigned k = 0; k < n_position_type; k++)

          //Loop over transformation components
          for(unsigned i = 0; i < AnisotropicSolidNode::n_transformation_components(); i++)
            trans[i] += this->transformation_gen(l, k, i) * psi(l, k);

      double eig[3];
      get_eigen_vectors(trans, Transformations[ip], eig);

    }

  }

  /// Construct the local node n and return a pointer to it.
  /// Functions construct_node and construct_boundary_node have to be overloaded
  /// if the element class uses different nodes as compared to parent class
  Node* construct_node(const unsigned &n) {
    node_pt(n) = new AnisotropicSolidNode(lagrangian_dimension(),
                                          nnodal_lagrangian_type(),
                                          nodal_dimension(),
                                          nnodal_position_type(),
                                          required_nvalue(n));
    return node_pt(n);
  }

  ///\short  Construct the local node n and return
  /// a pointer to it. Additionally, create data for `history'
  /// values as required by timestepper
  ///
  /// Functions construct_node and construct_boundary_node have to be overloaded
  /// if the element class uses different nodes as compared to parent class
  Node* construct_node(const unsigned &n,
                       TimeStepper* const &time_stepper_pt) {
    node_pt(n) = new AnisotropicSolidNode(time_stepper_pt,
                                          lagrangian_dimension(),
                                          nnodal_lagrangian_type(),
                                          nodal_dimension(),
                                          nnodal_position_type(),
                                          required_nvalue(n));
    return node_pt(n);
  }

  /// \short Construct the local node n and return a pointer to it.
  /// in the case when it is a boundary node; that is it MAY be
  /// located on a Mesh boundary
  ///
  /// Functions construct_node and construct_boundary_node have to be overloaded
  /// if the element class uses different nodes as compared to parent class
  Node* construct_boundary_node(const unsigned &n) {
    node_pt(n) =
      new BoundaryNode<AnisotropicSolidNode>(lagrangian_dimension(),
          nnodal_lagrangian_type(),
          nodal_dimension(),
          nnodal_position_type(),
          required_nvalue(n));

    return node_pt(n);
  }

  ///\short  Construct the local node n and return
  /// a pointer to it, in the case when the node MAY be located
  /// on a boundary. Additionally, create data for `history'
  /// values as required by timestepper
  ///
  // Functions construct_node and construct_boundary_node have to be overloaded
  /// if the element class uses different nodes as compared to parent class
  Node* construct_boundary_node(const unsigned &n,
                                TimeStepper* const &time_stepper_pt) {

    node_pt(n) =
      new BoundaryNode<AnisotropicSolidNode>(time_stepper_pt,
          lagrangian_dimension(),
          nnodal_lagrangian_type(),
          nodal_dimension(),
          nnodal_position_type(),
          required_nvalue(n));

    return node_pt(n);
  }

  /// This function is called to initialize data at integration points of finite elements
  /// by SolidMeshWithDataAtIntegrationPoints::initialize_data_at_integration_points.
  /// In this class it creates an array of transformation tensors
  void initialize_data_at_integration_points() {

#ifdef PARANOID

    if(integral_pt()) {
#endif
      Transformations = new DenseMatrix<double>[integral_pt()->nweight()];
      unsigned dim = nodal_dimension();

      for(unsigned ii = 0; ii < integral_pt()->nweight(); ii++)
        Transformations[ii].resize(dim, dim);

#ifdef PARANOID
    } else
      throw OomphLibError(
        "integral object is not assigned",
        "initialize_transformation_data()",
        OOMPH_EXCEPTION_LOCATION);

#endif

  }


  const DenseMatrix<double> &get_transformation_tensor_at_integration_point(unsigned ipt) const {
    return Transformations[ipt];
  }

private:
  double transformation_gen(const unsigned &n, const unsigned &k,
                            const unsigned &i) const {
    return static_cast<AnisotropicSolidNode*>(node_pt(n))->transformation_gen(k, i);
  }
  DenseMatrix<double>* Transformations;
};



/// \short Finite elements with active models in integration points
template <class ACTIVE_MODEL>
class ActiveFiniteElement : public virtual SolidFiniteElement,
  public virtual DataAtIntegrationPoints
{
public:
  /// \short constructor
  ActiveFiniteElement() : SolidFiniteElement(), Active_models(0) {}

  /// This function is called to initialize data at integration points of finite elements
  /// by SolidMeshWithDataAtIntegrationPoints::initialize_data_at_integration_points.
  /// In this class we create an array of active models, initialize them, and assign global
  /// time variable.
  void initialize_data_at_integration_points() {
#ifdef PARANOID

    if(integral_pt()) {
#endif
      Active_models = new ACTIVE_MODEL[integral_pt()->nweight()];

      for(unsigned ii = 0; ii < integral_pt()->nweight(); ii++)
        Active_models[ii].initialize();

#ifdef PARANOID
    } else
      throw OomphLibError(
        "integral object is not assigned",
        "ActiveFiniteElement::initialize_model_data()",
        OOMPH_EXCEPTION_LOCATION);

#endif

  }
  /// \short give pointer of global time variable to active models
  void assign_time_to_active_models(const double* const time) {
    for(unsigned ii = 0; ii < integral_pt()->nweight(); ii++)
      Active_models[ii].time_variable_pt() = time;
  }

  /// \short pointer to active model in integration point ipt
  ACTIVE_MODEL* get_active_model_at_integration_point(unsigned ipt) const {
    return &(Active_models[ipt]);
  }
  //void* &get_integration_point_data(int point){
  //  return Integration_point_data[point];
  //}
private:
  ACTIVE_MODEL* Active_models;
};


/// \short Class which overloads PVDEquations::fill_in_generic_contribution_to_residuals_pvd
/// and add in this funcition a call to ActionBeforeStressCalculation::action_before_sigma_calculation
/// right before a call to ConstitutiveLaw::calculate_second_piola_kirchhoff_stress
template <unsigned DIM>
class ActionBeforeStressCalculation : public virtual PVDEquations<DIM>
{
public:
  ActionBeforeStressCalculation() : PVDEquations<DIM>() {}
  /// \brief Integrate the weak form of momentuum equations and fill the linearized system with coefficients
  ///
  /// This function is
  /// copied from PVDEquations class. This function calls
  /// AnisotropicPVDEquations::action_before_sigma_calculation to modify parameters of constitutive laws, such as active tension, at every integration point.
  virtual void fill_in_generic_contribution_to_residuals_pvd(Vector<double> &residuals,
      DenseMatrix<double> &jacobian,
      const unsigned& flag);
protected:
  /// \short Implement some action before calculation of sigma in
  /// AnisotropicPVDEquations::fill_in_generic_contribution_to_residuals_pvd
  /// by ConstitutiveLaw::calculate_second_piola_kirchhoff_stress
  ///
  /// This function is convinient to set different parameters at every integration point.
  virtual void action_before_sigma_calculation(unsigned) {}

private:
};


template <unsigned DIM>
class AnisotropicPVDEquations : public virtual ActionBeforeStressCalculation<DIM>,
  public virtual AnisotropicFiniteElement
{
public:
  AnisotropicPVDEquations(): ActionBeforeStressCalculation<DIM>(),
    AnisotropicFiniteElement() {}
protected:
  /// \short Implement some action before calculation of sigma in
  /// AnisotropicPVDEquations::fill_in_generic_contribution_to_residuals_pvd
  /// by ConstitutiveLaw::calculate_second_piola_kirchhoff_stress
  ///
  /// This function sets transformation tensor at integration point.
  void action_before_sigma_calculation(unsigned ipt) {
    static_cast<AnisotropicConstitutiveLaw*>(this->Constitutive_law_pt)->transformation_pt() = &(this->get_transformation_tensor_at_integration_point(ipt));
  }

};


/// \short An element that solves the solid mechanics equations,
/// based on the principle of virtual displacements in Cartesian coordinates,
/// using SolidTElements for the interpolation of the variable positions.
///
/// This class includes functionality of anisotropic element (AnisotropicPVDEquations).
template<unsigned DIM, unsigned NNODE_1D>
class AnisotropicTPVDElement : public virtual TPVDElement<DIM, NNODE_1D>,
  public virtual  AnisotropicPVDEquations<DIM>
{
public:
  /// \short Constructor.
  AnisotropicTPVDElement() : TPVDElement<DIM, NNODE_1D>(),  AnisotropicPVDEquations<DIM>() { }

};


/// \short Face geometry class of anisotropic element.
///
/// All TPVDElement elements should have FaceGeometry class. This class is used
/// to create traction elemenents.
template<unsigned NNODE_1D>
class FaceGeometry<AnisotropicTPVDElement<3, NNODE_1D> > :
  public virtual SolidTElement<2, NNODE_1D>
{
public:
  FaceGeometry() : SolidTElement<2, NNODE_1D>() {}
};

/// \short Face geometry class of anisotropic element.
///
/// All TPVDElement elements should have FaceGeometry class. This class is used
/// to create traction elemenents.
template<unsigned NNODE_1D>
class FaceGeometry<FaceGeometry<AnisotropicTPVDElement<3, NNODE_1D> > > :
  public virtual SolidTElement<1, NNODE_1D>
{
public:
  FaceGeometry() : SolidTElement<1, NNODE_1D>() {}
};



/// \short An element that solves the solid mechanics equations,
/// based on the principle of virtual displacements in Cartesian coordinates,
/// using SolidTElements for the interpolation of the variable positions.
///
/// This class includes functionality of active element (ActiveFiniteElement).
/// In addition this class set pointers to active model in the integration points.
template<unsigned DIM, unsigned NNODE_1D, class ACTIVE_MODEL>
class ActiveTPVDElement : public virtual TPVDElement<DIM, NNODE_1D>,
  public virtual ActiveFiniteElement<ACTIVE_MODEL>,
  public virtual ActionBeforeStressCalculation<DIM>
{
public:
  /// \short Constructor.
  ActiveTPVDElement() : TPVDElement<DIM, NNODE_1D>(), 
    ActiveFiniteElement<ACTIVE_MODEL>(), ActionBeforeStressCalculation<DIM>() { }

protected:
  /// \short Implement some action before calculation of sigma in
  /// AnisotropicPVDEquations::fill_in_generic_contribution_to_residuals_pvd
  /// by ConstitutiveLaw::calculate_second_piola_kirchhoff_stress
  ///
  /// This function sets active model at integration point.
  void action_before_sigma_calculation(unsigned ipt) {
    dynamic_cast<InterfaceToConstitutiveLawActiveComponent*>(this->constitutive_law_pt())->set_active_model(this->get_active_model_at_integration_point(ipt));
  }
};



/// \short Face geometry class of active element.
///
/// All TPVDElement elements should have FaceGeometry class. This class is used
/// to create traction elemenents.
template<unsigned NNODE_1D, class ACTIVE_MODEL>
class FaceGeometry<ActiveTPVDElement<3, NNODE_1D, ACTIVE_MODEL> > :
  public virtual SolidTElement<2, NNODE_1D>
{
public:
  FaceGeometry() : SolidTElement<2, NNODE_1D>() {}
};

/// \short Face geometry class of active element.
///
/// All TPVDElement elements should have FaceGeometry class. This class is used
/// to create traction elemenents.
template<unsigned NNODE_1D, class ACTIVE_MODEL>
class FaceGeometry<FaceGeometry<ActiveTPVDElement<3, NNODE_1D, ACTIVE_MODEL> > > :
  public virtual SolidTElement<1, NNODE_1D>
{
public:
  FaceGeometry() : SolidTElement<1, NNODE_1D>() {}
};



/// \short An element that solves the solid mechanics equations,
/// based on the principle of virtual displacements in Cartesian coordinates,
/// using SolidTElements for the interpolation of the variable positions.
///
/// This class includes functionality of both, active (ActiveTPVDElement)
/// and anisotropic (AnisotropicTPVDElement) elements.
template<unsigned DIM, unsigned NNODE_1D, class ACTIVE_MODEL>
class ActiveAnisotropicTPVDElement : public virtual ActiveTPVDElement<DIM, NNODE_1D, ACTIVE_MODEL>,
  public virtual AnisotropicTPVDElement<DIM, NNODE_1D>
{
public:
  /// \short Constructor.
  ActiveAnisotropicTPVDElement() : ActiveTPVDElement<DIM, NNODE_1D, ACTIVE_MODEL>(), AnisotropicTPVDElement<DIM, NNODE_1D>() { }

  /// This function is called to initialize data at integration points of finite elements
  /// by SolidMeshWithDataAtIntegrationPoints::initialize_data_at_integration_points.
  /// In this class it creates an array of transformation tensors,
  /// creates an array of active models, initializes them, and assigns global
  /// time variable.
  void initialize_data_at_integration_points() {
    AnisotropicFiniteElement::initialize_data_at_integration_points();
    ActiveFiniteElement<ACTIVE_MODEL>::initialize_data_at_integration_points();
  }
  /// \short Implement some action before calculation of sigma in
  /// AnisotropicPVDEquations::fill_in_generic_contribution_to_residuals_pvd
  /// by ConstitutiveLaw::calculate_second_piola_kirchhoff_stress
  ///
  /// This function sets active model and transformation tensor at integration point.
  void action_before_sigma_calculation(unsigned ipt) {
    AnisotropicPVDEquations<DIM>::action_before_sigma_calculation(ipt);
    ActiveTPVDElement<DIM, NNODE_1D, ACTIVE_MODEL>::action_before_sigma_calculation(ipt);
  }
};


/// \short Face geometry class of active anisotropic element.
///
/// All TPVDElement elements should have FaceGeometry class. This class is used
/// to create traction elemenents.
template<unsigned NNODE_1D, class ACTIVE_MODEL>
class FaceGeometry<ActiveAnisotropicTPVDElement<3, NNODE_1D, ACTIVE_MODEL> > :
  public virtual SolidTElement<2, NNODE_1D>
{
public:
  FaceGeometry() : SolidTElement<2, NNODE_1D>() {}
};


/// \short Face geometry class of active anisotropic element.
///
/// All TPVDElement elements should have FaceGeometry class. This class is used
/// to create traction elemenents.
template<unsigned NNODE_1D, class ACTIVE_MODEL>
class FaceGeometry<FaceGeometry<ActiveAnisotropicTPVDElement<3, NNODE_1D, ACTIVE_MODEL> > > :
  public virtual SolidTElement<1, NNODE_1D>
{
public:
  FaceGeometry() : SolidTElement<1, NNODE_1D>() {}
};

//////////////////////////////////////////////////////////////////////


/// \short This class is for debugging proposes.
///
/// It was used to test reduced integration scheme. It will be used in the future.
template<unsigned DIM, unsigned NNODE_1D>
class TPVDElementReducedIntegration : public virtual oomph::TPVDElement<DIM, NNODE_1D>
{
public:
  TPVDElementReducedIntegration(): TPVDElement<DIM, NNODE_1D>() {
    set_integration_scheme(&(Reduced_integration_scheme));
  }
  static TGauss < DIM, NNODE_1D - 1 > Reduced_integration_scheme;
};

/// \short Face geometry class of element with reduced integration.
///
/// All TPVDelement elements should have FaceGeometry class. This class is used
/// to create traction elemenents.
template<unsigned NNODE_1D>
class FaceGeometry<TPVDElementReducedIntegration<3, NNODE_1D> > :
  public virtual SolidTElement<2, NNODE_1D>
{
public:
  FaceGeometry() : SolidTElement<2, NNODE_1D>() {}
};
/// \short Face geometry class of element with reduced integration.
///
/// All TPVDelement elements should have FaceGeometry class. This class is used
/// to create traction elemenents.
template<unsigned NNODE_1D>
class FaceGeometry<FaceGeometry<TPVDElementReducedIntegration<3, NNODE_1D> > > :
  public virtual SolidTElement<1, NNODE_1D>
{
public:
  FaceGeometry() : SolidTElement<1, NNODE_1D>() {}
};


}

#endif


