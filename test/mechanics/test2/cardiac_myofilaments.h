#ifndef OOMPH_CARDIAC_MYOFILAMENTS_HEADER
#define OOMPH_CARDIAC_MYOFILAMENTS_HEADER

#include "cardiac_nodes.h"
#include "cardiac_utilities.h"

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

//OOMPH-LIB includes
#include <constitutive.h>
#include <generic.h>
#include <solid.h>

#include <algorithm>
#include <string.h>


namespace oomph
{

/// \short Abstract class for cardiac myofilament model
class ActiveModel
{
public:
  /// \short Constructor
  ActiveModel() {};
  /// \short Destructor
  virtual ~ActiveModel() {};

  /// This funciton called from ActiveConstitutiveLaw::calculate_second_piola_kirchhoff_stress.
  /// In child classes should add active stress to sigma
  virtual void add_active_stress(
    const oomph::DenseMatrix<double> &g, const oomph::DenseMatrix<double> &G,
    oomph::DenseMatrix<double> &sigma, const DenseMatrix<double>* transformation) = 0;
  /// \short In initialize child classes can carry out any actions
  virtual void initialize() = 0;
  /// \short reference to global time pointer
  const double* &time_variable_pt() {
    return Time;
  }

private:
  /// \short pointer to global time pointer
  const double *Time;
};

/// \short Basic myofilament model.
///
/// This model has parabolic shape of generated tension
class BasicActiveModel : public ActiveModel
{
public:
  /// \short Constructor.
  ///
  /// Constructor set default activation time = 0ms, twitch duration 200ms,
  /// and maximal tension 100 kPa
  BasicActiveModel(): ActiveModel(), Activation_time(0.0),
    Twitch_duration(200.0), Maximal_force(100.0) {}

  /// \short Tension of the basic muscle is a function of stretch ratio
  /// of the fiber and tension with parabolic shape.
  ///
  /// 0 - force at 0.6 stretch ratio and the slope of tension with respect to muscle length 1.66
  void add_active_stress(const oomph::DenseMatrix<double> &g, const oomph::DenseMatrix<double> &G,
                         oomph::DenseMatrix<double> &sigma, const DenseMatrix<double>* transformation) {

    if(tension_is_zero(*(time_variable_pt())))
      return;

    const unsigned dim = G.ncol();
    //rotation to fiber coordinate system
    double G00 = 0;

    for(unsigned ii = 0; ii < dim; ii++)
      for(unsigned jj = 0; jj < dim; jj++)
        G00 += (*transformation)(ii, 0) * (*transformation)(jj, 0) * G(ii, jj);

    double stretch_ratio = sqrt(G00);
    double factor = (stretch_ratio - 0.6) * 1.66;

    //rotatation back to global coordinate system
    for(unsigned ii = 0; ii < dim; ii++)
      for(unsigned jj = 0; jj < dim; jj++)
        sigma(ii, jj) += (*transformation)(ii, 0) * (*transformation)(jj, 0) *
                         factor * tension(*(time_variable_pt()));
  }
  void initialize() {};
private:
  double Activation_time;
  double Twitch_duration;
  double Maximal_force;
  /// If time is less than activation time or greater than
  /// activation time + twitch duration, function return 0.
  /// Function was incorporated to prevent unnecessary calculation when
  /// active tension is zero.
  bool tension_is_zero(double time) {
    double model_time = time - Activation_time;
    return ((model_time < 0) || (model_time > Twitch_duration));
  }

  /// \short tension function, which has parabola's shape
  double tension(double time) {
    double model_time = time - Activation_time;
    return -(model_time - Twitch_duration) * model_time / Twitch_duration / Twitch_duration * 4.0 * Maximal_force;
  }


};

}

#endif


