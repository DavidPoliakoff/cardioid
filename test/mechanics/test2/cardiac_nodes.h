#ifndef OOMPH_CARDIAC_NODES_HEADER
#define OOMPH_CARDIAC_NODES_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

//OOMPH-LIB headers
#include <constitutive.h>
#include <generic.h>
#include <solid.h>

#include <algorithm>
#include <string.h>


namespace oomph
{


/// \brief SolidNode, which contains n_position_type transformation tensors.
///
/// This class contains n_position_type (number of DOFs per positional variable in the node)
/// matricies to define rotation transformation. Matricies represented by an 6-element array of
/// lower triangular part of the 3x3 matrix in the row-major format. Rotational transformation
/// can be obtained by get_eigen_vectors.
///  For more details about vector-space of tensors see Arsigny et al.
/// "Log‚ÄêEuclidean metrics for fast and simple calculus on diffusion tensors"
class AnisotropicSolidNode : public SolidNode
{
  friend class AnisotropicFiniteElement;
public:
  /// \short Default Constructor
  AnisotropicSolidNode() : SolidNode() {}

  static const unsigned &n_transformation_components() {
    return N_rotation_components;
  }

  ~AnisotropicSolidNode() {
    free_memory_transformation_components();
  }

  void free_memory_transformation_components() {
    if(transformation_components)
      delete [] transformation_components;
  }

  AnisotropicSolidNode(const unsigned &n_lagrangian,
                       const unsigned &n_lagrangian_type,
                       const unsigned &n_dim,
                       const unsigned &n_position_type,
                       const unsigned &initial_n_value) : SolidNode(n_lagrangian, n_lagrangian_type, n_dim,
                             n_position_type, initial_n_value) {
    transformation_components = new double[N_rotation_components * n_position_type];
  }
  AnisotropicSolidNode(TimeStepper* const &time_stepper_pt,
                       const unsigned &n_lagrangian,
                       const unsigned &n_lagrangian_type,
                       const unsigned &n_dim,
                       const unsigned &Nposition_type,
                       const unsigned &initial_n_value) : SolidNode(time_stepper_pt, n_lagrangian, n_lagrangian_type,
                             n_dim, Nposition_type, initial_n_value) {
    transformation_components = new double[N_rotation_components * Nposition_type];
  }
  double transformation_gen(const unsigned &k,
                            const unsigned &i) const {
    return transformation_components[N_rotation_components * k + i];
  }

  double* transformation_component(unsigned position_type) {
    return &transformation_components[position_type * N_rotation_components];
  }

  const double* transformation_component(unsigned position_type) const {
    return &(transformation_components[position_type * N_rotation_components]);
  }

protected:

private:
  static const unsigned N_rotation_components = 6;
  double* transformation_components;

};

}

#endif


